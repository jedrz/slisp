\documentclass[a4paper,11pt]{article}
\usepackage[MeX]{polski}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage[pdftex]{graphicx}
\usepackage{hyperref}
% \hypersetup{colorlinks=true}
\usepackage{amsmath}
\usepackage{color}
\usepackage[usenames]{xcolor}
\frenchspacing
% Wstawki tak jak w pliku źródłowym.
% \usepackage[section]{placeins} (niekoniecznie)
\usepackage[]{float}
\restylefloat{figure}
\usepackage{longtable}
\usepackage{minted}


\newcommand{\clj}[1]{\inputminted[fontsize=\footnotesize]{clojure}{code/#1.clj}}


\author{Łukasz Jędrzejewski}
\title{Techniki kompilacji -- projekt wstępny}
\date{}

\begin{document}

\maketitle

\section{Wstęp}

Projekt dotyczy napisania interpretera prostego języka podobnego do~wielu
dialektów LISP-a~w~języku Java 8.

\section{Konstrukcje języka}

\subsection{Ewaluacja form}

Obliczenie wyrażenia listowego polega na:
\begin{enumerate}
\item obliczenie pierwszego elementu, którego wartość powinna być funkcją lub
  specjalną formą,
\item obliczenie argumentów czyli reszty elementów wyrażenia w~przypadku
  funkcji, lub nie w~przypadku specjalnej formy,
\item wywołanie funkcji z~tak przygotowanymi wartościami.
\end{enumerate}

Na~przykład \verb|(+ 1 (- a))|:
\begin{enumerate}
\item obliczenie \verb|+|, czyli zwrócenie globalnej funkcji \verb|+|
\item obliczenie 1, czyli wynikiem będzie 1,
\item obliczenie \verb+(- a)+:
  \begin{enumerate}
  \item obliczenie -,
  \item obliczenie \verb+a+, czyli wartość symbolu, np. 5,
  \item wywołanie funkcji - z~argumentem 5, wynik -5
  \end{enumerate}
\item wywołanie funkcji \verb|+| z~argumentami: 1 oraz -5, wynik -4.
\end{enumerate}

Warto zaznaczyć, że~każde wywołanie zawsze coś zwraca, np. wywołanie \verb+if+
zwraca wynik drugiego lub ostatniego wyrażenia.

Dodatkowo żadna funkcja za~wyjątkiem \verb+set!+, nie modyfikuje wartości
przekazywanych argumentów.

\subsection{Typy}

\begin{description}
\item[symbol] czyli zmienna z~pewną wartościa,
\item[liczba] liczba zmiennoprzecinkowa,
\item[napis]
\item[lista] np., \verb+(list a 1 "napis")+ zwróci listę zawierającą wartość
  symbolu \verb+a+, liczbę 1 oraz napis. Dodatkowo listę można utworzyć
  poprzez wykorzystanie funkcji \verb+quote+, która zapobiega obliczeniu
  podanej listy w~argumencie, np. \verb+(quote (a 1 "napis"))+ zwróci
  \verb+(a 1 "napis")+, symbol \verb+a+ nie zostanie obliczony. Równoważne
  wywołaniu \verb+quote+ jest użycie apostrofu w~następujący sposób:
  \verb+'(a 1 "napis")+.
\end{description}

Dodatkowo symbol \verb+true+ jest zastrzeżony i~traktowany jako prawda,
a~symbol \verb+false+ jako fałsz. Jedynie symbol \verb+false+ będzie miał
wartość logiczną fałsz, czyli 0, pusta lista, pusty napis nie będą fałszywe
w~sensie logicznym.

\subsection{Specjalne formy}

Czyli ,,funkcje'', których wywołanie nie powoduje obliczania argumentów.

\begin{description}
\item[apostrof '] nie oblicza wyrażenia.
  \clj{quote}

\item[inny-apostrof `] nie oblicza wyrażenia, ale pozwala na~obliczanie
  oznaczonych wyrażeń.

\item[tylda \textasciitilde] oblicza wyrażenie w~ramach wyrażenia poprzedzonego
  \verb+`+.
  \clj{unquote}

\item[tylda+małpa \textasciitilde@] dodaje listę do~zacytowanej
  \clj{unquote-splicing}

\item[set!] przypisanie.
  \clj{set!}

\item[def] definicja zmiennej.
  \clj{def}

\item[defn] definicja funkcji. Użycie \verb+&+ oznacza, że~pozostałe argumenty
  zostaną przekazane jako lista.
  \clj{defn}

\item[fn] funkcja anonimowa.

\item[do] wykonuje kolejno podane wyrażenia i~zwraca wynik ostatniego.

\item[if] zwraca wynik wykonania drugiego wyrażenia, jeśli pierwsze wyrażenie
  oblicza się do~prawdy, lub ostatniego, wykonując kolejno wyrażenia od~3
  do~ostatniego.
  \clj{if}

\item[while] wykonuje wyrażenia od~drugiego do~ostatniego o~ile zachodzi
  warunek podany jako pierwszy argument.
  \clj{while}

\item[let] deklaracja zmiennych lokalnych.
  \clj{let}
\end{description}

\subsection{Prymitywy}

\begin{description}
\item[equals] porównuje podane argumenty.

\item[and, or] zwraca odpowiednio iloczyn oraz sumę logiczną podanych
  argumentów.

\item[help] zwraca dokumentację symbolu.

\item[load] ładuje plik z~kodem.
\end{description}

\subsubsection{Funkcje wyższego rzędu}

Czyli funkcje przyjmujące funkcje jako argumenty.

\begin{description}
\item[map] dla każdego elementu listy wywołuje podaną funkcję i~zwraca listę
  zmapowanych elementów.
  \clj{map}

\item[filter] zwraca listę zawierającą elementy spełniający podany predykat.
  \clj{filter}

\item[reduce] wywołuje funkcję z~akumulatorem i~elementem listy, której wynik
  jest staje się nowym akumulatorem. Jeśli trzeci argument jest dany, wtedy
  w~pierwszym kroku akumulator jest równy temu argumentowi. W przeciwnym
  wypadku akumulatorem staje się pierwszy element listy, a przekazywanym
  elementem drugi.
  \clj{reduce}

\item[apply] wywołuje podaną funkcję z~argumentami zawarty w~podanej liście.
  \clj{apply}

\end{description}

\subsubsection{Operacje na~liczbach}

\begin{description}
\item[+ - * /] podstawowe funkcje matematyczne przyjmujące dowolną ilość
  argumentów.

\item[$> \ >= \ = \ <= \ <$] predykaty porównujące podane liczby (możliwie
  więcej niż 2).

\item[zero?] czy liczba jest równa 0.
\end{description}

\subsubsection{Operacje na~listach i~napisach}

\begin{description}
\item[count] zwraca długość napisu lub listy.
\end{description}

\subsubsection{Operacje na~listach}

\begin{description}
\item[first] zwraca pierwszy element listy.

\item[rest] zwraca listę bez pierwszego elementu.

\item[list] zwraca listę złożoną z~podanych argumentów.

\item[cons] zwraca listę z~dodanym pierwszym argumentem na~początek listy.

\item[conj] zwraca listę z~dodanym drugim argumentem na~koniec listy.

\item[nth] zwraca element o~podanym indeksie.

\item[empty?] czy lista jest pusta.

\end{description}

\subsubsection{Operacje na~napisach}

\begin{description}
\item[concat] zwraca napis będący konkatenacją podanych.

\item[subs] zwraca podciąg o~podanym zakresie.
  \clj{subs}
\end{description}

\subsubsection{Wejście-wyjście}

\begin{description}
\item[print] drukuje napis.
\item[read] wczytuje linię i~ją~zwraca.
\end{description}

\section{Wymagania}

\subsection{Funkcjonalne}

\begin{enumerate}
\item Interpreter powinien pozwolić na~ewaluację form korzystających
  z~powyższych funkcji umieszczonych w~pliku lub podawanych przez użytkownika
  w~trybie konwersacyjnym.
\item W~trybie konwersacyjnym wynik obliczenia formy powinien być wypisany
  w~następnej linii.
\item Podczas wywołania funkcji, wszystkie funkcje, które są~używane
  w~wywoływanej funkcji powinny być zdefiniowane. Jeśli nie są, użytkownik
  zostanie powiadomiony o~niezdefiniowanym symbolu.
\item Dopuszczalne jest użycie niezdefiniowanych funkcji w~definicji funkcji.
\item Wszystkie symbole mogą być nadpisane oprócz \verb+true+ i~\verb+false+.
\item Nadmiarowe nawiasy są~dopuszczalne, jednak użytkownik zostanie
  poinformowany o~tym zajściu.
\item Brakujące nawiasy spowodują wystąpienie błędu.
\item W~przypadku błędu w~ciele funkcji, błąd zostanie zgłoszony dopiero
  podczas jej użycia.
\item Niepoprawne użycie funkcji powinno zostać zasygnalizowane.
\end{enumerate}

\subsection{Niefunkcjonalne}

\section{Analizator leksykalny}

Zadaniem analizatora leksykalnego jest rozpoznawanie następujących tokenów
w~strumieniu wejściowym:

\begin{table}[H]
  \centering
  \begin{tabular}{|p{6cm} p{6cm}|} \hline
    symbol & \\
    napis & tekst zawarty w~podwójnych cudzysłowach \\ 
    liczba & \\ \hline
    nawias otwierający & \verb+(+ \\
    nawias zamykający & \verb+)+ \\ \hline
    nawias kwadratowy otwierający & \verb+[+ \\
    nawias kwadratowy zamykający & \verb+]+ \\ \hline
    apostrof & \verb+'+ \\
    tylda & \verb+~+ \\
    małpa & \verb+@+ \\
    tylda+małpa & \verb+~@+ \\
    ampersand & \verb+&+ \\ \hline
  \end{tabular}
\end{table}

\section{Analizator składniowy}

Tworzy drzewo odpowiadające podanemu wyrażeniu przetwarzając kolejno tokeny.

Kiedy napotka token oznaczający:
\begin{description}
\item[symbol] zwraca obiekt opisujący symbol,
\item[liczbę] zamienia napis na~liczbę zmiennoprzecinkową i~ją~zwraca,
\item[napis] zwraca obiekt opisujący napis,
\item[nawias otwierający] tworzy nową listę, do~której dodaje sparsowane tokeny
  do~momentu napotkania nawiasu zamykającego, zwraca tak zbudowaną listę. Jeśli
  nie napotka nawiasu zamykającego, sygnalizowany jest błąd składni,
\item[nawias zamykający] powinien być przetworzony przy obsłudze nawiasu
  otwierającego, oznacza niepotrzebny nawias zamykający,
\item[nawiasy kwadratowe] postępuje analogicznie jak w~przypadku nawiasów
  okrągłych.
\end{description}

\section{Interpreter}

Interpreter powinien przyjmować wyrażenie do~ewaluacji w~postaci drzewa
będącego wynikiem działania analizator składniowego. Najważniejszym jego
elementem będzie metoda \verb+eval+, która zwraca wynik ewaluacji formy.

\subsection{Zakres}

Zakres, czyli mapa symboli i~wartości im~przypisanym. Na~początku interpreter
ma~zdefiniowany globalny zakres, w~którym są~umieszczone wbudowane prymitywy
oraz specjalne formy. Oprócz tego dodane zostają funkcje napisane
w~implementowanym języku.

Każdy zakres lokalny, utworzony np. podczas deklaracji zmiennych lokalnych
przechowuje odnośnik do~nadrzędnego zakresu.

Wyszukiwanie podanego symbolu polega na~odszukaniu go~w~zakresie. Jeśli symbol
nie zostaje znaleziony, wtedy należy spróbować znaleźć go~w~nadrzędnym
zakresie. Jeśli poszukiwanie się nie powiodło, oznacza to, że~symbol jest
niezdefiniowany.

\subsection{Metoda eval}

Metoda eval działa rekurencyjnie i~zwraca wynik ewaluacji podanego wyrażenia.
Kiedy otrzyma:
\begin{description}
\item[liczbę] zwraca liczbę,
\item[napis] zwraca napis,
\item[symbol] odszukuje w~bieżącym zakresie symbol i~zwraca jego wartość,
\item[lista] wtedy należy obliczyć pierwszy element (rekurencyjnie wywołać
  \verb+eval+ dla pierwszego elementu). Jeśli obliczony element jest funkcją
  lub prymitywem wtedy należy obliczyć argumenty i~wywołać funkcję. Jeśli zaś
  ten element jest specjalną formą, należy ją~wywołać z~nieobliczonymi
  argumentami.
\end{description}

\subsection{Funkcja}

Funkcja zdefiniowana za~pomocą \verb+fn+ lub \verb+defn+ jest reprezentowana
jako obiekt zawierający listę nazw argumentów (symboli), ciało funkcji
w~postaci jednego wyrażenia oraz zakres, w~którym funkcja została zdefiniowana.

\subsubsection{Wywołanie funkcji}

Wywołanie zdefiniowanej przez użytkownika funkcji wymaga stworzenia nowego
zakresu, którego zakresem nadrzędnym będzie zakres funkcji rozszerzony
o~symbole, czyli nazwy argumentów w~definicji funkcji oraz odpowiadające
im~wartości przekazane w~wywołaniu. Następnie jest wywoływana funkcja
\verb+eval+ w~celu obliczenia ciała funkcji w~otoczeniu podanego zakresu.

\end{document}
